<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no" />
        
        <!-- Leaflet CSS -->
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
         integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
         crossorigin=""/>

        <!-- RESTORE Perspective Preload/CSS -->
        <link rel="preload" href="https://cdn.jsdelivr.net/npm/@finos/perspective-viewer/dist/wasm/perspective-viewer.wasm" as="fetch" type="application/wasm" crossorigin="anonymous" />
        <link rel="preload" href="https://cdn.jsdelivr.net/npm/@finos/perspective/dist/wasm/perspective-server.wasm" as="fetch" type="application/wasm" crossorigin="anonymous" />
        <link rel="stylesheet" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@finos/perspective-viewer/dist/css/themes.css" />
        <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.3/umd/index.min.js"></script>
        
        <!-- Leaflet JS -->
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
          crossorigin=""></script>
          
        <style>
            /* Ensure body fills viewport */
            html, body {
                height: 100%;
                margin: 0;
                padding: 0;
                overflow: hidden; /* Prevent scrollbars */
            }

            perspective-viewer {
                position: absolute;
                top: 0;
                left: 0;
                bottom: 0;
                right: 0;
            }

            /* Style for Leaflet Map */
            #leaflet-map {
                position: absolute;
                top: 0;
                left: 0;
                /* bottom: 0;  Explicit height is often more reliable */
                /* right: 0; */
                width: 100%;
                height: 100%; 
                z-index: 1;
            }

            /* RESTORE Marker and Animation Styles */
            .leaflet-rect-icon div {
                border-radius: 1px;
            }
            .leaflet-line-icon div {
                /* No specific border-radius needed for line segment */
            }
            .leaflet-custom-icon div {
                width: 100%;
                height: 100%;
                border: none; 
                box-shadow: 0 0 6px 2px rgba(255, 255, 255, 0.5);
                transform-origin: center center; 
            }

            /* RESTORE Coordinate and Info Display CSS */
             #coord-display {
                position: absolute;
                bottom: 10px; 
                right: 10px;
                background-color: rgba(0, 0, 0, 0.6);
                color: #fff;
                padding: 3px 6px;
                font-family: monospace;
                font-size: 12px;
                border-radius: 3px;
                z-index: 10; 
                pointer-events: none; 
            }
            #marker-info {
                position: absolute;
                bottom: 35px; 
                right: 10px;
                background-color: rgba(0, 0, 0, 0.7);
                color: #fff;
                padding: 3px 6px;
                font-family: sans-serif;
                font-size: 13px;
                border-radius: 3px;
                z-index: 10; 
                pointer-events: none; 
                max-width: 200px; 
                text-align: right;
            }

            /* --- ADD NEW ChatGPT suggested Amorphous Glow CSS --- */
            @keyframes glow-spread {
                0% {
                    opacity: 0.7;
                    transform: scale(0.5) translateX(0px);
                    filter: blur(8px);
                }
                100% {
                    opacity: 0;
                    transform: scale(2.5) translateX(var(--spread-distance));
                    filter: blur(25px);
                }
            }

            /* --- ADD Static Gate CSS --- */
            .static-gate-marker div {
                border-radius: 50%;
                width: 20px;
                height: 20px;
                box-shadow: 0 0 8px rgba(0,0,0,0.4);
            }

            /* START: Timeline Visualization CSS */
            #timeline-container {
                position: absolute;
                bottom: 30px; /* Adjust height above bottom */
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 1200px; /* Limit maximum width */
                background-color: rgba(20, 20, 20, 0.9);
                color: #eee;
                z-index: 1000; /* Ensure it's above most map elements */
                box-shadow: 0 4px 12px rgba(0,0,0,0.5);
                border-radius: 10px;
                padding: 0; /* Remove container padding, handle in controls/wrapper */
                display: flex; /* Use flex for internal layout */
                flex-direction: column; /* Stack controls above chart */
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            }
            #timeline-controls {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 8px 15px; /* Increased horizontal padding from 20px to 30px */
                background-color: rgba(20, 20, 20, 0.95);
                font-family: 'Segoe UI', sans-serif;
                font-size: 14px;
                border-bottom: 1px solid #333;
                border-top-left-radius: 10px;
                border-top-right-radius: 10px;
                min-height: 28px; /* Ensure a minimum height */
            }

            /* Styling for the main groups */
            #tl-left-group,
            #tl-timeframe-display,
            #tl-info-display,
            #day-slider-group,
            #tl-mode-switcher {
              display: flex;
              align-items: center;
              gap: 10px; /* Increased from 6px to 10px for more spacing */
            }

            /* Specific overrides */
            #timeline-controls button {
                padding: 3px 8px; 
                background-color: #333;
                border: none;
                color: #ccc;
                border-radius: 3px;
                cursor: pointer;
                transition: background-color 0.2s ease, color 0.2s ease;
                font-size: 12px;
                font-weight: 500;
                line-height: 1.2;
                white-space: nowrap; /* Prevent text wrapping */
                display: inline-flex; /* Use flexbox for icon alignment */
                align-items: center; /* Center items vertically */
            }
            #timeline-controls button:hover {
                background-color: #484848; /* Subtle hover */
                color: #fff;
            }
            #timeline-controls button:disabled {
                background-color: #282828; /* Darker disabled */
                color: #666;
                cursor: default;
            }
            #timeline-controls label {
                margin-left: 0;
                color: #ccc;
                font-size: 13px; /* Reverted from 12px */
            }
            /* Specific label styles */
            #tl-timeframe-display {
              font-size: 13px;
              color: #ccc;
              font-style: italic;
            }
            #tl-info-text {
              font-weight: 600; /* Bolder */
              font-size: 15px; /* Slightly larger */
              color: #fff;
              min-width: 150px; /* Keep min-width */
              text-align: center;
            }
            #mode-display {
              font-weight: 500;
              min-width: 80px; /* Adjust as needed */
              text-align: center;
            }
            #chart-wrapper {
                width: 100%;
                overflow-x: scroll; 
                overflow-y: hidden;
                height: 100px; /* Increased from 89px to 100px to accommodate day labels */
                cursor: grab;
                white-space: nowrap; 
                background-color: #2a2a2a;
                border-bottom-left-radius: 10px;
                border-bottom-right-radius: 10px;
                padding: 0; 
                scrollbar-width: thin;
                scrollbar-color: #666 #333;
            }
            #timeline-canvas {
                display: block; 
                height: 100px; /* Match the wrapper height */
                border: none;
            }
            /* Timeline Legend */
            #timeline-legend {
                position: absolute;
                top: 10px;
                right: 10px;
                left: auto;
                padding: 8px 12px;
                background-color: rgba(40, 40, 40, 0.85);
                border-radius: 6px;
                z-index: 1000; /* Ensure it's above the map and timeline */
                text-align: right;
                font-size: 14px;
                line-height: 1.4;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
                color: #ffffff;
                font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
                pointer-events: none; /* Allow clicks to pass through to map */
                max-width: 300px;
            }

            #tl-current-info {
                font-weight: bold;
                margin-top: 4px;
            }

            #tl-timeframe {
                opacity: 0.9;
            }
            
            /* Nice scrollbar for chart */
            #chart-wrapper::-webkit-scrollbar {
                height: 8px;
            }

            #chart-wrapper::-webkit-scrollbar-track {
                background: #333;
                border-radius: 4px;
            }

            #chart-wrapper::-webkit-scrollbar-thumb {
                background-color: #666;
                border-radius: 4px;
                border: 2px solid #333;
            }

            #chart-wrapper::-webkit-scrollbar-thumb:hover {
                background-color: #888;
            }
            
            /* Custom Slider Styles */
            input[type="range"] {
                -webkit-appearance: none; 
                appearance: none; 
                width: 100%; /* Default width for sliders */
                height: 4px; /* Thinner track */
                background: #555; /* Lighter track */
                border-radius: 2px;
                cursor: pointer;
                outline: none;
                transition: background 0.2s ease;
            }
            
            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none; 
                appearance: none; 
                width: 14px; /* Smaller thumb */
                height: 14px; 
                background: #4a90e2; /* Slightly different blue */
                border-radius: 50%; 
                cursor: pointer;
                border: none; /* Remove thumb border */
                box-shadow: 0 0 4px rgba(0,0,0,0.6); /* Subtle shadow */
                transition: background-color 0.2s ease;
            }
            
            input[type="range"]::-moz-range-thumb {
                width: 14px; /* Smaller thumb */
                height: 14px; 
                background: #4a90e2; /* Slightly different blue */
                border-radius: 50%; 
                cursor: pointer;
                border: none; /* Remove thumb border */
                box-shadow: 0 0 4px rgba(0,0,0,0.6); /* Subtle shadow */
                transition: background-color 0.2s ease;
            }
            
            input[type="range"]:hover {
                background: #666; /* Subtle track hover */
            }
            
            input[type="range"]:active::-webkit-slider-thumb {
                background-color: #6aaaf0; /* Lighter blue when active */
            }
            input[type="range"]:active::-moz-range-thumb {
                background-color: #6aaaf0; /* Lighter blue when active */
            }

            /* Specific width for day slider */
            #day-slider {
                width: 170px;
            }
            
            /* Time display styling */
            .time-label {
                color: #ddd;
                font-weight: 500;
                margin-right: 3px; /* Reduce margin */
            }
            
            #day-time-display {
                min-width: 70px; /* Keep smaller width */
                text-align: center;
                font-weight: 600;
                color: #fff;
                background-color: rgba(50, 50, 50, 0.7);
                padding: 2px 8px; /* Reverted horizontal padding */
                border-radius: 3px;
                font-size: 13px; /* Original size */
            }
            
            /* Pollution cloud styling */
            .leaflet-blob-icon {
                z-index: 400;
                pointer-events: none;
            }
            
            .leaflet-blob-icon span {
                z-index: 450;
                pointer-events: none;
                font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
            }
            
            /* CO2 emission label styling */
            .leaflet-blob-icon div {
                z-index: 1001 !important;
                background-color: rgba(0,0,0,0.8) !important;
                color: white !important;
                font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
                font-weight: bold !important;
                padding: 3px 6px !important;
                border-radius: 4px !important;
                border: 1px solid rgba(255,255,255,0.3) !important;
                white-space: nowrap !important;
                pointer-events: none !important;
            }
            
            /* CO2 text marker styling */
            .co2-text-marker {
                z-index: 1001;
            }

            .co2-text-marker div {
                background-color: rgba(0,0,0,0.8);
                color: white;
                font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
                font-weight: bold;
                font-size: 10px;
                padding: 3px 5px;
                border-radius: 3px;
                border: 1px solid rgba(255,255,255,0.5);
                box-shadow: 0 0 4px rgba(0,0,0,0.7);
                white-space: nowrap;
                pointer-events: none;
            }
            
        </style>
    </head>

    <body>
        <!-- Leaflet Map Container -->
        <div id="leaflet-map"></div>
        
        <!-- Timeline Legend - Moved outside timeline container -->
        <div id="timeline-legend">
          <div id="tl-timeframe">
            <span id="tl-left-label">Start</span> – <span id="tl-right-label">End</span>
          </div>
          <div id="tl-current-info">
            <span id="tl-info-text">--:-- – 0 entries</span>
          </div>
        </div>

        <div id="coord-display">Lat: ---, Lng: ---</div>
        <div id="marker-info"></div>

        <!-- START: Timeline Visualization HTML -->
        <div id="timeline-container">
            <div id="timeline-controls">
              <!-- Simplified to one row -->
              <div id="tl-left-group">
                <button id="tl-play-button"><span style="margin-right: 3px;">▶</span>Play</button>
                <button id="tl-pause-button" disabled><span style="margin-right: 3px;">⏸</span>Pause</button>
                <label for="tl-speed-slider">Speed:</label>
                <input type="range" id="tl-speed-slider" min="50" max="1000" step="50" value="200" />
              </div>
            
              <!-- Day Slider moved to center -->
              <div class="control-group" id="day-slider-group">
                <label for="day-slider" class="time-label">Time:</label>
                <input type="range" id="day-slider" title="Time of Day" min="0" max="143" value="0" style="width: 170px;"/>
                <span id="day-time-display">00:00 AM</span>
              </div>
            
              <!-- Mode Switcher at right -->
              <div class="control-group" id="tl-mode-switcher">
                <button id="mode-toggle">Change Mode</button>
                <span id="mode-display">Mode: Pollution</span>
              </div>
            </div>
            
            <div id="chart-wrapper">
                <canvas id="timeline-canvas"></canvas>
            </div>
        </div>
        <!-- END: Timeline Visualization HTML -->

        <!-- RESTORE Original Script Logic -->
        <script type="module">
            // ADDING BACK viewer import
            import "https://cdn.jsdelivr.net/npm/@finos/perspective-viewer@3.4.3/dist/cdn/perspective-viewer.js";
            import { worker } from "https://cdn.jsdelivr.net/npm/@finos/perspective@3.4.3/dist/cdn/perspective.js";

            const WORKER = await worker();
            const DATA_FILE_PATH = "mta_map.arrow";
            
            let leafletMap = null; 
            let perspectiveView = null; 
            let markersLayer = null; 
            let congestionTable = null; 
            let baseViewConfig = {}; 
            let isViewerReady = false; // Add back readiness flag
            const markerInfoElement = document.getElementById('marker-info'); // Add back element ref

            // const glowLayer = document.getElementById('glow-layer'); 
            let glowLayerGroup = null; // Initialize Leaflet layer group later

            let activeBaseMarkers = {};
            let activeStaticColorMarkers = {};

            let currentMode = 'pollution'; // Changed from 'blobs' to 'pollution'
            const modes = ['pollution', 'tax', 'congestion']; // Changed from 'blobs', 'emoji', 'staticColor'
            let isPlaying = false; // Flag for playback state
            let showCO2Labels = true; // Flag to control CO2 label display

            // --- Timeline Visualization Variables ---
            let canvas = null;
            let ctx = null;
            let chartWrapper = null;
            let tlPlayButton = null;
            let tlPauseButton = null;
            let tlSpeedSlider = null;
            let leftLabel = null;
            let rightLabel = null;
            let infoText = null;
            let csvData = []; // Holds [Date, value] pairs
            let labels = [];  // Holds Date objects
            let data = [];    // Holds numeric values (entries)
            const barWidth = 10; 
            const minutesPerDay = 144; // 24 * 6
            let currentIndex = 0;
            let intervalId = null;
            let isTimePlaying = false; // New flag for time playback
            let timeIntervalId = null;
            let daySlider = null; 
            let dayTimeDisplay = null; 
            let chartContext = null; // Store canvas context and dimensions
            // ------------------------------------

            // --- Restore Mode Toggle Variable Declarations ---
            let modeToggleBtn = null;
            let modeDisplay = null;

            // --- Helper for Gate Color ---
            function getGateColor(entries) {
                if (entries > 230) return {bg: '#555555', border: '#d73027', opacity: 0.85};
                if (entries > 170) return {bg: '#666666', border: '#fc8d59', opacity: 0.8};
                if (entries > 120) return {bg: '#777777', border: '#fee08b', opacity: 0.75};
                return {bg: '#888888', border: '#91cf60', opacity: 0.7};
            }
            // --- END Helper ---

            // --- Load Arrow Data --- (Restore)
            async function get_preprocessed_congestion_data() {
                console.log(`Fetching PREPROCESSED Arrow data from ${DATA_FILE_PATH}`);
                try {
                    const resp = await fetch(DATA_FILE_PATH);
                    if (!resp.ok) {
                        throw new Error(`HTTP error! status: ${resp.status} while fetching ${DATA_FILE_PATH}`);
                    }
                    const arrayBuffer = await resp.arrayBuffer();
                    console.log("Loading Arrow data into Perspective");
                    const table = await WORKER.table(arrayBuffer);
                    console.log("Arrow Data loaded successfully");
                    return table;
                } catch (e) {
                     console.error(`Error fetching or processing data from ${DATA_FILE_PATH}:`, e);
                     document.getElementById('leaflet-map').innerHTML = `<p style="color: red; padding: 20px;">Error loading data: ${e.message}. Check console.</p>`;
                     throw e;
                }
            }
            
            // --- Helper to format slider value (Keep)
            function formatTimeDisplay(sliderValue) {
                const totalMinutes = sliderValue * 10;
                const hours24 = Math.floor(totalMinutes / 60);
                const minutes = totalMinutes % 60;
                
                // Convert to 12-hour format with AM/PM
                const period = hours24 >= 12 ? 'PM' : 'AM';
                const hours12 = hours24 % 12 || 12; // Convert 0 to 12 for 12 AM
                
                return `${String(hours12).padStart(2, '0')}:${String(minutes).padStart(2, '0')} ${period}`;
            }
            
            // --- Helper to generate the filter string (Keep)
            function getTollBlockFilterString(dateStr, sliderValue) {
                if (!dateStr) return null; 
                try {
                    const dateObj = new Date(dateStr + 'T00:00:00Z'); 
                    if (isNaN(dateObj)) return null; 
                    const totalMinutes = sliderValue * 10;
                    dateObj.setUTCMinutes(totalMinutes);
                    const options = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true, timeZone: 'UTC' };
                    let formatted = new Intl.DateTimeFormat('en-US', options).format(dateObj);
                    formatted = formatted.replace(',', ''); 
                    return formatted;
                } catch (e) {
                    console.error("Error formatting date/time string:", e);
                    return null;
                }
            }
            
            // --- Helper function to aggregate data for the timeline (Daily) --- 
            async function getTimelineData() {
              if (!congestionTable) {
                console.error("Cannot get timeline data: congestionTable not ready.");
                return [];
              }
            
              console.log("Aggregating DAILY data for timeline chart...");
              // Group by the new DateOnly column
              const timelineViewConfig = {
                group_by: ["DateOnly"],
                columns: ["CRZ_Entries"],
                aggregates: { "CRZ_Entries": "sum" },
                sort: [["DateOnly", "asc"]] // Sort by the date string
                // No need for the null filter here, DateOnly should exist
              };
            
              try {
                const timelineView = await congestionTable.view(timelineViewConfig);
                const timelineJson = await timelineView.to_json();
                await timelineView.delete(); 
                console.log(`Daily timeline data fetched: ${timelineJson.length} rows.`);
                // console.log("Daily JSON preview:", timelineJson.slice(0, 5)); 

                // Convert to [Date, value] array, parsing the DateOnly string
                const dailyData = [];
                timelineJson.forEach(row => {
                    if (row.__ROW_PATH__ && row.__ROW_PATH__[0]) {
                        const dateStr = row.__ROW_PATH__[0]; // Should be 'YYYY-MM-DD'
                        const totalEntries = row.CRZ_Entries || 0;
                        
                        // Parse 'YYYY-MM-DD' string - safer to specify UTC to avoid timezone shift
                        const dateObj = new Date(dateStr + 'T00:00:00Z'); 
                        
                        if (!isNaN(dateObj.getTime())) {
                            dailyData.push([dateObj, totalEntries]);
                        } else {
                             console.warn(`Could not parse DateOnly string: "${dateStr}"`);
                        }
                    }
                });

                // Sorting should already be handled by Perspective query, but double-check just in case
                dailyData.sort((a, b) => a[0].getTime() - b[0].getTime());

                console.log(`Processed daily timeline data points: ${dailyData.length}`);
                return dailyData;

              } catch (e) {
                console.error("Error creating or fetching DAILY timeline view:", e);
                return [];
              }
            }
            // --- END Timeline Data Helper ---

            // --- applyTimeFilter Function ---
            async function applyTimeFilter(dateStr, timeBlockVal) {
                if (!isViewerReady || !congestionTable) {
                    console.warn("Perspective table not ready, skipping update.");
                    return;
                }
                
                const targetTimeString = getTollBlockFilterString(dateStr, timeBlockVal);
                let newFilter = [["latitude", "is not null"]];
                if (targetTimeString) {
                    newFilter.push(["Toll_10_Minute_Block", "==", targetTimeString]);
                } else {
                    console.warn("Cannot generate time string...");
                }
                
                try {
                    // Ensure previous view is properly deleted first
                    if (perspectiveView) {
                        try {
                            console.log("Cleaning up previous Perspective view");
                            await perspectiveView.delete();
                            perspectiveView = null;
                        } catch (e) {
                            console.warn("Error deleting previous Perspective view:", e);
                            // Continue anyway - the old view might already be garbage collected
                        }
                    }
                    
                    console.log("Creating new Perspective view with filter:", JSON.stringify(newFilter));
                    const currentViewConfig = { ...baseViewConfig, filter: newFilter };
                    
                    try {
                        perspectiveView = await congestionTable.view(currentViewConfig);
                        console.log("New Perspective view created successfully");
                    } catch (viewError) {
                        console.error("Failed to create Perspective view:", viewError);
                        // Try with a simpler filter as fallback
                        console.log("Trying with simpler filter as fallback");
                        perspectiveView = await congestionTable.view(baseViewConfig);
                    }

                    console.log("Fetching filtered JSON data");
                    const filteredJson = await perspectiveView.to_json();
                    console.log(`Retrieved ${filteredJson.length} data points`);

                    const processedLocations = new Set();
                    
                    filteredJson.forEach(row => {
                        const locationName = row.__ROW_PATH__ ? row.__ROW_PATH__[0] : 'Unknown';
                        if (locationName === 'Unknown') return;

                        processedLocations.add(locationName);
                        const entries = row.CRZ_Entries || 0;
                        const lat = row.latitude;
                        const lon = row.longitude;
                        const vehicleClass = row.Vehicle_Class || '';
                        const timePeriod = row.Time_Period || '';

                        if (lat != null && lon != null) {
                            if (!activeBaseMarkers[locationName]) {
                                const newBaseMarker = L.circleMarker([lat, lon], {
                                    radius: 6, fillColor: "#555555", color: "#000",
                                    weight: 1, opacity: 0.6, fillOpacity: 0.4
                                });
                                newBaseMarker.bindPopup(`<b>${locationName}</b><br>Entries: ${entries.toLocaleString()}<br>Period: ${timePeriod}`);
                                newBaseMarker.addTo(markersLayer);
                                newBaseMarker.on('mouseover', (e) => { markerInfoElement.textContent = locationName; });
                                newBaseMarker.on('mouseout', (e) => { markerInfoElement.textContent = ''; });
                                activeBaseMarkers[locationName] = newBaseMarker;
                            } else {
                                const existingBaseMarker = activeBaseMarkers[locationName];
                                existingBaseMarker.setPopupContent(`<b>${locationName}</b><br>Entries: ${entries.toLocaleString()}<br>Period: ${timePeriod}`);
                            }

                            if (currentMode === 'congestion') {
                                const colorInfo = getGateColor(entries);
                                const existingStaticMarker = activeStaticColorMarkers[locationName];

                                if (entries > 0) {
                                    if (!existingStaticMarker) {
                                        const newStaticMarker = L.circleMarker([lat, lon], {
                                            radius: 12,
                                            fillColor: colorInfo.bg,
                                            color: colorInfo.border,
                                            weight: 2,
                                            opacity: 0.95,
                                            fillOpacity: 0.9,
                                            interactive: false
                                        }).addTo(markersLayer);
                                        activeStaticColorMarkers[locationName] = newStaticMarker;
                                    } else {
                                        existingStaticMarker.setStyle({
                                            fillColor: colorInfo.bg,
                                            color: colorInfo.border,
                                            radius: 12,
                                            opacity: 0.95,
                                            fillOpacity: 0.9
                                        });
                                    }
                                } else {
                                    if (existingStaticMarker) {
                                        markersLayer.removeLayer(existingStaticMarker);
                                        delete activeStaticColorMarkers[locationName];
                                    }
                                }
                            } else {
                                if (entries > 0) {
                                    createAndAnimateVisual(lat, lon, entries, vehicleClass, timePeriod);
                                }
                            }
                        }
                    });

                    for (const locationName in activeBaseMarkers) {
                        if (!processedLocations.has(locationName)) {
                            const baseMarkerToRemove = activeBaseMarkers[locationName];
                            if (markersLayer.hasLayer(baseMarkerToRemove)) {
                                markersLayer.removeLayer(baseMarkerToRemove);
                            }
                            delete activeBaseMarkers[locationName];

                            const staticMarkerToRemove = activeStaticColorMarkers[locationName];
                            if (staticMarkerToRemove && markersLayer.hasLayer(staticMarkerToRemove)){
                                markersLayer.removeLayer(staticMarkerToRemove);
                                delete activeStaticColorMarkers[locationName];
                            }
                        }
                    }

                } catch (e) {
                    console.error("Error applying filter or updating Leaflet map:", e);
                    if (isPlaying && tlPauseButton) {
                        console.log("Stopping playback due to error in applyTimeFilter.");
                        tlPauseButton.click();
                    }
                }
            }

            async function load() {
                console.log("--- Starting load() function ---");
                try {
                    console.log("Initializing Leaflet map...");
                    leafletMap = L.map('leaflet-map', {
                        zoomSnap: 0.1,        // Allow finer zoom levels (default is 1)
                        zoomDelta: 0.2,       // Smaller zoom changes with keyboard/buttons
                        wheelPxPerZoomLevel: 80 // More scroll wheel movement needed per zoom level
                    }).setView([40.7128, -74.0060], 11);
                    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                        attribution: '&copy; OpenStreetMap contributors &copy; CARTO',
                        subdomains: 'abcd',
                        maxZoom: 19
                    }).addTo(leafletMap);
                    markersLayer = L.layerGroup().addTo(leafletMap);
                    glowLayerGroup = L.layerGroup().addTo(leafletMap);
                    console.log("Leaflet map and layer groups initialized.");

                    const coordDisplayElement = document.getElementById('coord-display');
                    if (coordDisplayElement) {
                      leafletMap.on('mousemove', function(e) {
                          const lat = e.latlng.lat.toFixed(6);
                          const lng = e.latlng.lng.toFixed(6);
                          coordDisplayElement.textContent = `Lat: ${lat}, Lng: ${lng}`;
                      });
                      leafletMap.on('mouseout', function() {
                          coordDisplayElement.textContent = `Lat: ---, Lng: ---`;
                      });
                    }

                    console.log("Attempting to load PREPROCESSED Arrow data...");
                    congestionTable = await get_preprocessed_congestion_data();
                    console.log("Preprocessed Arrow data loaded into 'congestionTable'.");

                    console.log("Defining base Perspective view config...");
                    baseViewConfig = {
                        group_by: ["Detection_Group"],
                        columns: ["longitude", "latitude", "CRZ_Entries", "Vehicle_Class", "Time_Period"],
                        aggregates: { 
                            "longitude": "avg", 
                            "latitude": "avg", 
                            "CRZ_Entries": "sum",
                            "Vehicle_Class": "dominant",  // Get the dominant vehicle class
                            "Time_Period": "dominant"     // Get the dominant time period
                        },
                        filter: [["latitude", "is not null"]]
                    };

                    console.log("Creating Perspective view...");
                    perspectiveView = await congestionTable.view(baseViewConfig);
                    console.log("Perspective view created.");

                    isViewerReady = true;
                    console.log("Perspective Table and View are ready. Initializing controls.");

                    console.log("--- load() function completed successfully! --- ");

                    console.log("Initializing timeline visualization...");
                    canvas = document.getElementById('timeline-canvas');
                    ctx = canvas.getContext('2d');
                    chartWrapper = document.getElementById('chart-wrapper');
                    tlPlayButton = document.getElementById('tl-play-button');
                    tlPauseButton = document.getElementById('tl-pause-button');
                    tlSpeedSlider = document.getElementById('tl-speed-slider');
                    leftLabel = document.getElementById('tl-left-label');
                    rightLabel = document.getElementById('tl-right-label');
                    infoText = document.getElementById('tl-info-text');

                    if (!canvas || !chartWrapper || !tlPlayButton || !tlPauseButton || !tlSpeedSlider || !leftLabel || !rightLabel || !infoText) {
                        console.error("FATAL: Could not find all timeline visualization elements!");
                        return;
                    }

                    csvData = await getTimelineData();

                    if (!csvData || csvData.length === 0) {
                        console.error("FATAL: No data returned for timeline visualization!");
                        infoText.textContent = "Error loading timeline data.";
                        return;
                    }

                    labels = csvData.map(([ts]) => ts);
                    data = csvData.map(([, v]) => v);

                    chartContext = setupCanvas(csvData);
                    if (!chartContext) {
                        console.error("FATAL: Failed to setup timeline canvas!");
                        infoText.textContent = "Error initializing timeline chart.";
                        return;
                    }
                    canvas = document.getElementById('timeline-canvas');
                    chartWrapper = document.getElementById('chart-wrapper');

                    function convertSliderToSpeed(sliderVal) {
                        return 1050 - sliderVal;
                    }

                    function startTimePlayback() {
                        if (!chartContext || labels.length === 0) return;

                        // Always stop existing playback first before starting new playback
                        if (isTimePlaying) {
                            clearInterval(timeIntervalId);
                            timeIntervalId = null;
                        }

                        const dateForPlayback = labels[currentIndex];
                        if (!dateForPlayback || !(dateForPlayback instanceof Date) || isNaN(dateForPlayback)) {
                            console.error("Cannot start time playback: Invalid date selected on main timeline.", currentIndex, labels[currentIndex]);
                            return;
                        }
                        const dateStr = dateForPlayback.toISOString().split('T')[0];

                        console.log(`Starting TIME playback for date: ${dateStr}`);
                        isTimePlaying = true;
                        tlPlayButton.disabled = true;
                        tlPauseButton.disabled = false;

                        // Get the latest speed setting from the slider
                        const intervalDelay = convertSliderToSpeed(tlSpeedSlider.value);
                        console.log(`Using interval delay: ${intervalDelay}ms from slider value: ${tlSpeedSlider.value}`);

                        timeIntervalId = setInterval(() => {
                            let currentDaySliderValue = parseInt(daySlider.value);
                            currentDaySliderValue = (currentDaySliderValue + 1) % 144;
                            daySlider.value = currentDaySliderValue;
                            dayTimeDisplay.textContent = formatTimeDisplay(currentDaySliderValue);

                            applyTimeFilter(dateStr, currentDaySliderValue);

                        }, intervalDelay);
                    }

                    function stopTimePlayback() {
                        if (!isTimePlaying) return;
                        console.log("Stopping TIME playback...");
                        clearInterval(timeIntervalId);
                        timeIntervalId = null;
                        isTimePlaying = false;
                        tlPlayButton.disabled = false;
                        tlPauseButton.disabled = true;
                    }

                    function updateChart(highlightIndex = -1, updateMap = false) {
                        const canvasInfo = chartContext;
                        if (!canvasInfo || !canvasInfo.ctx || !canvasInfo.canvasWidth || !canvas || data.length === 0) {
                            console.error("updateChart: Missing canvas context or data.");
                            return;
                        }
                        const { ctx, canvasWidth, canvasHeight: logicalCanvasHeight, barWidth: totalBarWidth, actualBarWidth, totalBars } = canvasInfo;

                        ctx.fillStyle = '#2a2a2a';
                        ctx.fillRect(0, 0, canvasWidth, logicalCanvasHeight);

                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillRect(0, 0, canvasWidth, 15);
                        ctx.fillRect(0, logicalCanvasHeight - 15, canvasWidth, 15);

                        const hasInvalidData = data.some(val => !Number.isFinite(val) || val < 0);
                        if (hasInvalidData) {
                            console.warn("WARNING: Timeline 'data' array contains non-finite or negative values.");
                        }

                        const maxVal = Math.max(...data.filter(val => Number.isFinite(val) && val > 0), 1);

                        const dayNames = ['S', 'M', 'T', 'W', 'T', 'F', 'S'];
                        const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

                        const logIndices = new Set([0, 1, 2]);
                        if (highlightIndex >= 0 && highlightIndex < totalBars) logIndices.add(highlightIndex);

                        data.forEach((val, i) => {
                            if (i >= totalBars) return;

                            const isValidValue = Number.isFinite(val) && val >= 0;
                            const currentVal = isValidValue ? val : 0;
                            const availableBarHeight = logicalCanvasHeight - 30;
                            const logicalBarHeight = Math.max(0, (currentVal / maxVal) * availableBarHeight);

                            ctx.fillStyle = i === highlightIndex ? '#ffffff' : '#aaaaaa';

                            const x = i * totalBarWidth;
                            const y = 15 + (availableBarHeight - logicalBarHeight);
                            const barDrawingWidth = actualBarWidth;
                            const barDrawingHeight = Math.max(0, logicalBarHeight);

                            if (barDrawingHeight > 0 && barDrawingWidth > 0) {
                                ctx.fillRect(x, y, barDrawingWidth, barDrawingHeight);
                            }
                        });

                        for (let i = 0; i < Math.min(labels.length, totalBars); i++) {
                            if (!labels[i] || !(labels[i] instanceof Date)) continue;

                            const dateObj = labels[i];
                            const dayOfMonth = dateObj.getDate();
                            // Get day of week in UTC to match the legend display
                            const dayOfWeek = dateObj.getUTCDay();
                            const xCenter = i * totalBarWidth + totalBarWidth / 2;

                            if (dayOfMonth === 1 || i === 0) {
                                const monthIndex = dateObj.getUTCMonth();
                                ctx.fillStyle = '#ccc';
                                ctx.font = 'bold 10px sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText(monthNames[monthIndex], xCenter, 12);

                                ctx.strokeStyle = '#666';
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.moveTo(i * totalBarWidth, 15);
                                ctx.lineTo(i * totalBarWidth, logicalCanvasHeight - 15);
                                ctx.stroke();
                            }

                            ctx.fillStyle = '#bbb';
                            ctx.font = '9px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.fillText(dayNames[dayOfWeek], xCenter, logicalCanvasHeight - 5);
                        }

                        const viewWidth = chartWrapper.clientWidth;
                        const scrollLeft = chartWrapper.scrollLeft;
                        const firstVisibleIndex = Math.max(0, Math.min(Math.floor(scrollLeft / totalBarWidth), labels.length - 1));
                        const lastVisibleIndex = Math.max(0, Math.min(Math.floor((scrollLeft + viewWidth) / totalBarWidth) -1 , labels.length - 1));

                        const dateFormatOptions = { month: 'short', day: 'numeric', weekday: 'short', timeZone: 'UTC' };
                        leftLabel.textContent = labels[firstVisibleIndex]?.toLocaleDateString('en-US', dateFormatOptions) || '';
                        rightLabel.textContent = labels[lastVisibleIndex]?.toLocaleDateString('en-US', dateFormatOptions) || '';

                        const centerIndex = Math.max(0, Math.min(Math.floor((scrollLeft + viewWidth / 2) / totalBarWidth), labels.length - 1));
                        const indexToUse = (highlightIndex >= 0 && highlightIndex < labels.length) ? highlightIndex : centerIndex;

                        if (labels[indexToUse]) {
                            const entryValue = (indexToUse < data.length && Number.isFinite(data[indexToUse])) ? data[indexToUse].toLocaleString() : 'N/A';
                            infoText.textContent = `${labels[indexToUse].toLocaleDateString('en-US', dateFormatOptions)} - ${entryValue} entries`;

                            if (updateMap) {
                                const dateForMap = labels[indexToUse];
                                if (dateForMap instanceof Date && !isNaN(dateForMap)){
                                    const dateStr = dateForMap.toISOString().split('T')[0];
                                    const timeBlockVal = parseInt(daySlider.value);

                                    console.log(`Timeline requesting map update for Date: ${dateStr}, Time Block Val: ${timeBlockVal} (from daySlider)`);
                                    applyTimeFilter(dateStr, timeBlockVal);
                                } else {
                                    console.warn(`Cannot update map: Invalid date found at index ${indexToUse}`);
                                }
                            }
                        } else {
                            console.warn(`Label not found for index: ${indexToUse}`);
                            infoText.textContent = '';
                        }
                    }
                    
                    tlPlayButton.addEventListener('click', startTimePlayback);

                    tlPauseButton.addEventListener('click', stopTimePlayback);

                    tlSpeedSlider.addEventListener('input', () => {
                        if (!chartContext) return;

                        const newSpeed = convertSliderToSpeed(tlSpeedSlider.value);
                        console.log(`Speed slider adjusted to: ${newSpeed}ms (slider value: ${tlSpeedSlider.value})`);
                    });
                    
                    // Add change event handler - fires when user releases the slider
                    tlSpeedSlider.addEventListener('change', () => {
                        if (!chartContext) return;
                        
                        const newSpeed = convertSliderToSpeed(tlSpeedSlider.value);
                        console.log(`Speed slider released: ${newSpeed}ms (slider value: ${tlSpeedSlider.value})`);
                        
                        // If playback is active, restart it with the new speed
                        if (isTimePlaying) {
                            clearInterval(timeIntervalId);
                            timeIntervalId = null;
                            
                            // Restart playback with new speed
                            const intervalDelay = newSpeed;
                            const dateForPlayback = labels[currentIndex];
                            const dateStr = dateForPlayback.toISOString().split('T')[0];
                            
                            console.log(`Restarting playback with new speed: ${intervalDelay}ms`);
                            
                            timeIntervalId = setInterval(() => {
                                let currentDaySliderValue = parseInt(daySlider.value);
                                currentDaySliderValue = (currentDaySliderValue + 1) % 144;
                                daySlider.value = currentDaySliderValue;
                                dayTimeDisplay.textContent = formatTimeDisplay(currentDaySliderValue);
                                
                                applyTimeFilter(dateStr, currentDaySliderValue);
                            }, intervalDelay);
                        }
                    });

                    let scrollTimeout;
                    chartWrapper.addEventListener('scroll', () => {
                      if (!chartContext) return;
                       const { barWidth: totalBarWidth } = chartContext;

                      if (isTimePlaying) stopTimePlayback();

                      updateChart(-1, false);
                      clearTimeout(scrollTimeout);
                      scrollTimeout = setTimeout(() => {
                        const scrollCenter = chartWrapper.scrollLeft + chartWrapper.clientWidth / 2;
                        const centerIndex = Math.max(0, Math.min(Math.floor(scrollCenter / totalBarWidth), labels.length - 1));
                        console.log(`Scroll ended, updating map to daily index: ${centerIndex}`);
                        currentIndex = centerIndex;
                        updateChart(currentIndex, true);
                      }, 250);
                    });

                    canvas.addEventListener('click', (event) => {
                        if (!chartContext) return;
                         const { barWidth: totalBarWidth } = chartContext;

                        if (isTimePlaying) stopTimePlayback();

                        const rect = canvas.getBoundingClientRect();
                        const x = event.clientX - rect.left;
                        const index = Math.floor(x / totalBarWidth);
                        if (index >= 0 && index < data.length) {
                            currentIndex = index;
                            console.log(`Canvas clicked, updating map to daily index: ${index}`);
                            updateChart(currentIndex, true);
                        }
                    });

                    daySlider = document.getElementById('day-slider');
                    dayTimeDisplay = document.getElementById('day-time-display');
                    if (daySlider && dayTimeDisplay) {
                        // Initialize display with correct formatting
                        dayTimeDisplay.textContent = formatTimeDisplay(parseInt(daySlider.value));
                        
                        let daySliderTimeout;
                        daySlider.addEventListener('input', () => {
                            if (isTimePlaying) stopTimePlayback();

                            const sliderValue = parseInt(daySlider.value);
                            dayTimeDisplay.textContent = formatTimeDisplay(sliderValue);

                            // Don't update map on every input event to avoid performance issues
                            // We'll update on change/release instead
                        });
                        
                        // Add change event listener that fires when user releases the slider
                        daySlider.addEventListener('change', () => {
                            const sliderValue = parseInt(daySlider.value);
                            const currentTimelineIndex = currentIndex;
                            const datePartSource = labels[currentTimelineIndex] || (labels.length > 0 ? labels[0] : new Date());
                            let dateStr = '2025-01-05';
                            if (datePartSource instanceof Date && !isNaN(datePartSource)) {
                                dateStr = datePartSource.toISOString().split('T')[0];
                            } else {
                                console.warn("Could not determine current date from timeline for daySlider update, using default.");
                            }

                            console.log(`Day slider released: Updating map to ${dateStr}, sliderVal ${sliderValue}`);
                            applyTimeFilter(dateStr, sliderValue);
                        });
                    } else {
                        console.error("Could not find Day Slider elements!");
                    }

                    setTimeout(() => {
                        console.log("Performing initial timeline draw and map sync...");
                        updateChart(-1, true);
                    }, 50);

                    window.addEventListener('resize', () => {
                        console.log("Window resized - Re-setting canvas and redrawing timeline chart");
                        updateChart(currentIndex, false);
                    });

                } catch(e) {
                     console.error("--- ERROR during load() function --- ", e);
                     document.getElementById('leaflet-map').innerHTML = `<p style="color: red; padding: 20px;">Error during data load/processing: ${e.message}. Check console.</p>`;
                }
            }
            
            const getBlobParams = (entries) => {
                if (entries > 200) return { size: '70px', opacity: 0.8, duration: '7s', spread: '120px' };
                if (entries > 150) return { size: '60px', opacity: 0.7, duration: '6s', spread: '100px' };
                if (entries > 100) return { size: '50px', opacity: 0.6, duration: '5s', spread: '80px' };
                if (entries > 0)  return { size: '40px', opacity: 0.5, duration: '4s', spread: '60px' };
                return { size: '30px', opacity: 0.4, duration: '3s', spread: '40px' };
            };

            const calculateRevenue = (entries, vehicleClass = '', timePeriod = '') => {
                if (entries === 0) return 0;

                // Standardize inputs
                const lc = (vehicleClass || '').toLowerCase();
                const isOvernight = (timePeriod || '').toLowerCase().includes('overnight');

                // --- Taxi & FHV Logic (Per Trip) ---
                if (lc.includes('taxi') || lc.includes('fhv')) {
                    const perTripRate = lc.includes('app') ? 1.50 : 0.75; // App-based FHV vs Yellow/Green taxi
                    return entries * perTripRate;
                }

                // --- Passenger Cars / Small Vans / Pickups (Class 1) ---
                if (lc.startsWith('1') || lc.includes('car') || lc.includes('sedan') || lc.includes('suv')) {
                    const base = 9.00;
                    return entries * (isOvernight ? base * 0.25 : base); // 75% discount overnight
                }

                // --- Motorcycles (Class 5) ---
                if (lc.startsWith('5') || lc.includes('motorcycle') || lc.includes('bike')) {
                    const base = 4.50;
                    return entries * (isOvernight ? base * 0.25 : base);
                }

                // --- Small Trucks (Class 2) ---
                if (lc.startsWith('2') || (lc.includes('truck') && lc.includes('small'))) {
                    const base = 14.40;
                    return entries * (isOvernight ? base * 0.25 : base);
                }

                // --- Large Trucks (Class 3) ---
                if (lc.startsWith('3') || (lc.includes('truck') && !lc.includes('small'))) {
                    const base = 21.60;
                    return entries * (isOvernight ? base * 0.25 : base);
                }

                // --- Buses (Class 4) ---
                if (lc.startsWith('4') || lc.includes('bus')) {
                    const base = 21.60;
                    return entries * (isOvernight ? base * 0.25 : base);
                }

                // --- Fallback ---
                return entries * (isOvernight ? 2.25 : 9.00); // Fallback to car rate
            };

            function createAndAnimateVisual(lat, lon, entries, vehicleClass, timePeriod) {
                const params = getBlobParams(entries);
                const sizePx = parseInt(params.size);
                const durationMs = parseFloat(params.duration) * 1000;
                const initialOpacity = params.opacity;

                let iconHtmlContent = '';
                let inlineStyle = '';
                let finalIconSizePx = sizePx;
                let useJsAnimation = false;
                let animationTarget = null;
                let markerClassName = 'leaflet-transient-visual';

                if (currentMode === 'tax') {
                    useJsAnimation = true;
                    const emojiSizePx = Math.max(8, Math.round(sizePx / 10));
                    finalIconSizePx = emojiSizePx;
                    markerClassName += ' leaflet-emoji-icon';
                    inlineStyle = `width: auto; height: ${emojiSizePx}px; font-size: ${emojiSizePx}px; text-align: center; line-height: ${emojiSizePx}px; pointer-events: none; color: gold; white-space: nowrap;`;
                    const revenue = calculateRevenue(entries, vehicleClass, timePeriod);
                    const revenueString = `$${(revenue/1000).toFixed(1)}k`;
                    iconHtmlContent = `<span style="text-shadow: 0 0 3px black; font-family:'Apple Color Emoji','Segoe UI Emoji','Noto Color Emoji',sans-serif;">&#128176;${revenueString}</span>`;
                    const verticalOffset = 0.01;
                    const randomHorizontalOffset = (Math.random() - 0.5) * 0.01;
                    animationTarget = [lat + verticalOffset, lon + randomHorizontalOffset];
                } else {
                    markerClassName += ' leaflet-blob-icon';
                    const colors = getGateColor(entries);
                    
                    // Create the cloud div with separate CO2 text
                    inlineStyle = `width: ${params.size}; height: ${params.size}; 
                        background-color: ${colors.bg}; border: 3px solid ${colors.border}; 
                        border-radius: 50%; filter: blur(5px); position: relative;
                        pointer-events: none; animation: glow-spread ${params.duration} ease-out forwards; 
                        --spread-distance: ${params.spread}; opacity: ${colors.opacity};`;
                    
                    // Cloud has no text content
                    iconHtmlContent = '';
                    
                    // Only create CO2 marker when in pollution mode AND showCO2Labels is true
                    if (currentMode === 'pollution' && showCO2Labels) {
                        // Calculate CO2 emissions for pollution mode
                        const co2Amount = calculateCO2Emissions(entries, vehicleClass);
                        
                        // Create a completely separate marker for the CO2 text that will remain visible
                        const co2Marker = L.marker([lat + 0.001, lon - 0.002], {
                            icon: L.divIcon({
                                className: 'co2-text-marker',
                                html: `<div>${co2Amount} kg</div>`,
                                iconSize: [70, 30],
                                iconAnchor: [35, 15]
                            }),
                            keyboard: false,
                            interactive: false
                        }).addTo(glowLayerGroup);
                    }
                }
                
                const visualIcon = L.divIcon({
                    className: markerClassName,
                    html: `<div style="${inlineStyle.replace(/\n\s*/g, '')}">${iconHtmlContent}</div>`,
                    iconSize: (currentMode === 'tax') ? null : [finalIconSizePx, finalIconSizePx],
                    iconAnchor: [finalIconSizePx / 2, finalIconSizePx / 2],
                });

                const marker = L.marker([lat, lon], {
                    icon: visualIcon,
                    keyboard: false,
                    interactive: false,
                    opacity: (currentMode !== 'tax') ? initialOpacity : 1.0
                }).addTo(glowLayerGroup);

                if (useJsAnimation && animationTarget) {
                    let startTime = null;
                    function animationStep(timestamp) {
                        if (!startTime) startTime = timestamp;
                        const elapsed = timestamp - startTime;
                        const t = Math.min(elapsed / durationMs, 1);
                        const currentLat = lat + (animationTarget[0] - lat) * t;
                        const currentLng = lon + (animationTarget[1] - lon) * t;
                        
                        if (!glowLayerGroup.hasLayer(marker)) return;
                        
                        marker.setLatLng([currentLat, currentLng]);
                        marker.setOpacity(initialOpacity * (1 - t));
                        
                        if (t < 1) {
                            requestAnimationFrame(animationStep);
                        } else {
                            if (glowLayerGroup.hasLayer(marker)) {
                                glowLayerGroup.removeLayer(marker);
                            }
                        }
                    }
                    requestAnimationFrame(animationStep);
                } else if (currentMode === 'pollution'){
                    setTimeout(() => {
                        if (glowLayerGroup.hasLayer(marker)) {
                           glowLayerGroup.removeLayer(marker);
                        }
                    }, durationMs);
                }
            }

            // Helper function to refresh the entire data pipeline when encountering persistent errors
            async function refreshDataPipeline() {
                console.log("Attempting to refresh data pipeline...");
                try {
                    // Clean up any existing views
                    if (perspectiveView) {
                        try {
                            await perspectiveView.delete();
                        } catch (e) {
                            console.warn("Error deleting perspective view during refresh:", e);
                        }
                        perspectiveView = null;
                    }
                    
                    // Create a fresh view with base config
                    perspectiveView = await congestionTable.view(baseViewConfig);
                    console.log("Successfully refreshed Perspective view");
                    
                    // Update the current display with simple filter
                    if (labels[currentIndex]) {
                        const dateForMap = labels[currentIndex];
                        const dateStr = dateForMap.toISOString().split('T')[0];
                        const timeBlockVal = parseInt(daySlider.value);
                        
                        // Add minimal filter to avoid potential issues
                        const simpleFilter = [["latitude", "is not null"]];
                        const safeViewConfig = { ...baseViewConfig, filter: simpleFilter };
                        
                        if (perspectiveView) {
                            await perspectiveView.delete();
                        }
                        perspectiveView = await congestionTable.view(safeViewConfig);
                        
                        // Update UI based on current mode
                        modeDisplay.textContent = `Mode: ${currentMode.charAt(0).toUpperCase() + currentMode.slice(1)}`;
                    }
                    
                    return true;
                } catch (e) {
                    console.error("Failed to refresh data pipeline:", e);
                    return false;
                }
            }
            
            modeToggleBtn = document.getElementById("mode-toggle");
            modeDisplay = document.getElementById("mode-display");
            if (modeToggleBtn && modeDisplay) {
                modeToggleBtn.addEventListener('click', async () => {
                    try {
                        const previousMode = currentMode;
                        let currentModeIndex = modes.indexOf(currentMode);
                        currentModeIndex = (currentModeIndex + 1) % modes.length;
                        currentMode = modes[currentModeIndex];
                        modeDisplay.textContent = `Mode: ${currentMode.charAt(0).toUpperCase() + currentMode.slice(1)}`;
                        console.log("Mode changed from", previousMode, "to:", currentMode);
                        
                        // Set CO2 display flag based on mode
                        if (currentMode === 'pollution') {
                            console.log("Entering pollution mode, enabling CO2 labels");
                            showCO2Labels = true;
                        } else if (previousMode === 'pollution') {
                            console.log("Leaving pollution mode, disabling CO2 labels");
                            showCO2Labels = false;
                            
                            // Remove any existing CO2 markers
                            glowLayerGroup.eachLayer(layer => {
                                if (layer.options.icon && layer.options.icon.options.className === 'co2-text-marker') {
                                    glowLayerGroup.removeLayer(layer);
                                }
                            });
                        }
                        
                        if (previousMode === 'congestion' && currentMode !== 'congestion') {
                            console.log("Cleaning up static color markers...");
                            for (const locationName in activeStaticColorMarkers) {
                                const markerToRemove = activeStaticColorMarkers[locationName];
                                if (markersLayer.hasLayer(markerToRemove)) {
                                    markersLayer.removeLayer(markerToRemove);
                                }
                            }
                            activeStaticColorMarkers = {};
                        }

                        // Add a small delay to ensure any cleanup operations are completed
                        // before applying new filters
                        setTimeout(async () => {
                            try {
                                console.log("Mode changed, re-applying filter based on timeline index:", currentIndex);
                                if (labels[currentIndex]) {
                                    const dateForMap = labels[currentIndex];
                                    const dateStr = dateForMap.toISOString().split('T')[0];
                                    const timeBlockVal = parseInt(daySlider.value);
                                    
                                    // Make sure we clean up any existing perspective view first
                                    if (perspectiveView) {
                                        try {
                                            await perspectiveView.delete();
                                            perspectiveView = null;
                                        } catch (viewError) {
                                            console.warn("Error cleaning up previous perspective view:", viewError);
                                        }
                                    }
                                    
                                    try {
                                        await applyTimeFilter(dateStr, timeBlockVal);
                                    } catch (filterError) {
                                        console.error("Error applying time filter, attempting recovery:", filterError);
                                        // If we encounter an error, try to refresh the entire data pipeline
                                        const refreshSuccess = await refreshDataPipeline();
                                        if (refreshSuccess) {
                                            // If refresh was successful, try again with a basic filter
                                            await applyTimeFilter(dateStr, timeBlockVal);
                                        }
                                    }
                                } else {
                                    console.error("Could not get valid date/time from timeline state for mode toggle update.");
                                }
                            } catch (filterError) {
                                console.error("Error applying filters after mode change:", filterError);
                            }
                        }, 100); // 100ms delay
                    } catch (err) {
                        console.error("Error during mode toggle:", err);
                    }
                });
            }

            function setupCanvas(data) {
                const canvas = document.getElementById('timeline-canvas');
                const ctx = canvas.getContext('2d');
                if (!canvas || !ctx || !data || data.length === 0) {
                    console.error('Failed to get canvas/context or data is empty for setupCanvas');
                    return null;
                }
    
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
    
                const barWidth = 10;
                const barSpacing = 2;
                const totalBarWidth = barWidth + barSpacing;
                const canvasHeight = 89;
                
                const canvasWidth = Math.max(2000, data.length * totalBarWidth);
    
                canvas.width = Math.round(canvasWidth * dpr);
                canvas.height = Math.round(canvasHeight * dpr);
    
                canvas.style.width = `${canvasWidth}px`;
                canvas.style.height = `${canvasHeight}px`;
    
                ctx.scale(dpr, dpr);
    
                console.log(`Canvas setup complete (Daily). Width: ${canvasWidth}px (${data.length} days @ ${totalBarWidth}px each)`);
                
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    
                return { ctx, canvasWidth, canvasHeight, barWidth: totalBarWidth, totalBars: data.length, actualBarWidth: barWidth };
            }

            // --- Calculate CO2 emissions based on vehicle type ---
            const calculateCO2Emissions = (entries, vehicleClass = '') => {
                if (entries === 0) return 0;
                
                // Standardize input
                const lc = (vehicleClass || '').toLowerCase();
                
                // CO2 emissions in kg per vehicle mile
                // Values are approximated based on EPA data
                let co2PerVehicle = 0;
                
                // --- TLC Taxi/FHV ---
                if (lc.includes('taxi') || lc.includes('fhv')) {
                    co2PerVehicle = 0.36; // Average sedan/SUV emissions
                }
                // --- Class 1: Cars, Pickups and Vans ---
                else if (lc.startsWith('1') || lc.includes('car') || lc.includes('sedan') || lc.includes('suv')) {
                    co2PerVehicle = 0.40; // Average passenger vehicle
                }
                // --- Class 2: Single-Unit Trucks ---
                else if (lc.startsWith('2') || (lc.includes('truck') && lc.includes('small'))) {
                    co2PerVehicle = 0.85; // Medium duty truck
                }
                // --- Class 3: Multi-Unit Trucks ---
                else if (lc.startsWith('3') || (lc.includes('truck') && !lc.includes('small'))) {
                    co2PerVehicle = 1.70; // Heavy-duty truck
                }
                // --- Class 4: Buses ---
                else if (lc.startsWith('4') || lc.includes('bus')) {
                    co2PerVehicle = 1.35; // Transit bus
                }
                // --- Class 5: Motorcycles ---
                else if (lc.startsWith('5') || lc.includes('motorcycle') || lc.includes('bike')) {
                    co2PerVehicle = 0.20; // Motorcycle
                }
                // --- Fallback to average vehicle ---
                else {
                    co2PerVehicle = 0.40; // Default to passenger vehicle
                }
                
                // Assume average trip distance of 5 miles into/through the congestion zone
                const avgTripMiles = 5;
                const totalCO2 = entries * co2PerVehicle * avgTripMiles;
                
                return Math.round(totalCO2); // Return rounded kg of CO2
            };

            load();
        </script>
    </body>
</html> 